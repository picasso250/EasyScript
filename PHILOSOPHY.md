# EasyScript 设计哲学

EasyScript 的设计围绕两大核心原则，旨在实现简洁、一致和可预测的编程体验。

## 1. 核心原则：一切皆表达式 (Everything is an Expression)

这是 EasyScript 最根本的哲学。

*   **无语句 (No Statements)**：语言中**没有 `Statement` (语句) 的概念**。传统语言中的 `if` 语句、`for` 循环、函数定义，甚至赋值，在 EasyScript 中全部都是表达式 (`Expression`)。
*   **万物皆有值**: 因为一切都是表达式，所以一切运算都会返回一个值。这消除了“语句”和“表达式”之间的概念鸿沟，创造了高度的语义统一性。
    *   `let a = 10` 这个表达式，返回 `10`。
    *   `if a > 5 { "big" } else { "small" }` 这个表达式，根据 `a` 的值返回 `"big"` 或 `"small"`。
    *   `fun(x) { x * x }` 这个表达式，返回一个可被调用的函数对象。
*   **隐式返回 (Implicit Return)**：函数体 (`Block`) 的返回值由其内部**最后一个表达式**的值决定。为了保持简洁性，显式的 `return` 关键字已被移除。
*   **副作用标记 (Side-effect Marking)**：当一个表达式的主要目的是其副作用（如赋值、打印）而非其返回值时，可以在其后加上分号 `;`。这会使整个表达式的最终返回值为 **`nil`**，清晰地向阅读者和编译器传达“我们不关心这个表达式的结果”。

## 2. 运行时哲学：清晰、可预测、不意外

EasyScript 在运行时奉行强类型和明确的规则，避免“魔法”和不可预期的行为。

*   **单一数字类型 (Single Number Type)**: 为了简化，EasyScript 内部只有一种数字类型：`f64` (64位浮点数)。无论是 `1`还是 `1.0`，都被视作同一种类型，避免了整数和浮点数之间的复杂转换规则。

*   **强类型运行时 (Strongly Typed Runtime)**：EasyScript 不会在不同类型之间进行隐式转换。
    *   `10 + "hello"` 会直接导致运行时错误，而不是像 JavaScript 那样将数字转换为字符串。
    *   **`+` 运算符的哲学**：`+` 运算符仅用于“连接”或“相加”两个**相同类型**的容器或值。
        *   **数字 + 数字**：数学加法。
        *   **字符串 + 字符串**：字符串拼接。
        *   **列表 + 列表**：列表拼接，返回一个包含两个列表所有元素的新列表。
        *   任何不符合以上规则的操作都会导致运行时错误。

*   **统一的真值规则 (Unified Truthiness Rules)**: 为了在便利性和严谨性之间取得平衡，EasyScript 的条件判断（如 `if` 表达式）和 `bool()` 类型转换函数遵循一套统一的、类似 Python 的真值规则。
    *   **假值 (Falsy)**: 以下值被视作 `false`：
        *   `nil`
        *   `false` (布尔值)
        *   数字 `0`
        *   空字符串 `""`
        *   空列表 `[]`
        *   空映射 `{}`
    *   **真值 (Truthy)**: 除上述假值之外的所有其他值都被视作 `true`。

*   **内置函数错误处理**: 对于如 `num()` 这样的类型转换内置函数，当转换失败（例如 `num("abc")`）或遇到不支持的类型时，它们会返回 **`nil`**，而不是抛出运行时错误。这使得脚本能够优雅地处理可预见的错误情况。只有当函数用法本身存在问题（如参数数量不正确）时，才会抛出运行时错误。

*   **空值哲学 (`nil`)**: 引入一个统一的 **`nil`** 值。
    *   `nil` 用于表示变量未赋值、字典查找失败、以及函数转换失败。
    *   `nil` **同时承担了 `unit/void` 的语义**，作为所有带有副作用的表达式（如 `a = 1;`）或缺少返回值分支的表达式（如无 `else` 的 `if`）的返回值。

## 3. 语法哲学：结构清晰

*   **Go-Style 控制流**：`if` 和 `for` 语句的条件表达式**无需使用圆括号**，减少了视觉噪音。
*   **强制表达式块**：`if`, `for`, `fun` 的代码体**必须**是表达式块 `{}` (`<BlockExpression>`)，这保证了结构清晰和返回值的一致性，避免了单行代码体可能带来的歧义。
*   **独立的 Block 表达式**: 独立的 `{}` 也是一个 Block 表达式，它是创建局部作用域和封装复杂逻辑的强大工具。例如 `let result = { let temp = 5; temp * 2 };`。

## 4. 标准库设计原则：全局函数 vs. 内置方法

为了在功能丰富性和语言简洁性之间取得平衡，EasyScript 的标准库遵循以下设计原则：

*   **全局内置函数 (Global Built-in Functions)**: 用于普适性、多态性强的操作。这类函数能作用于多种完全不同的类型，或者其功能不依附于任何特定类型。
    *   **示例**: `print(...)`, `type(value)`, `len(value)`。
    *   `len()` 是一个典型的多态函数，它可以获取字符串、列表和映射的长度。将其作为全局函数，比在每个类型上都实现一个 `.len()` 方法更为统一和方便。

*   **内置方法 (Built-in Methods)**: 用于特定类型的操作。当一个功能与某个数据类型紧密相关时，它应该被实现为该类型的方法，通过 `.` 运算符调用。
    *   **示例**: `my_map.keys()`, `my_string.trim()`。
    *   `keys()` 只对 `map` 类型有意义，`trim()` 只对 `string` 类型有意义。将它们实现为方法，可以使代码更具可读性，并避免污染全局命名空间。
    *   `.` **运算符行为**: `.` 运算符遵循“方法优先，属性回退”的原则。当解释器遇到 `my_map.keys` 时，它会首先检查 `map` 类型是否存在一个名为 `keys` 的内置方法。如果存在，则准备进行方法调用；如果不存在，则回退为访问 `my_map` 中键为 `"keys"` 的属性。
